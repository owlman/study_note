在理想情况下，我们当然会更希望能像许多科幻电影中那样，可以直接使用人类语言来向计算机传递操作指令。目前，计算机科学家们在这个方向上也的确取得了显着的进步，并开发出了一系列看似能理解人类语言的产品，例如Siri（苹果）、小艺（华为）等语音助手，以及ChatGPT（OpenAI）、文心一言（百度）这类更新一代的通用内容生成工具。然而，即使不考虑这些产品背后的数学真相，就算AI有一天真的能理解人类的语言，考虑到人类语言中天然存在的模糊性与不精确性，它本身也并不适合用于描述复杂的算法。例如，在“I saw the man in the park with the telescope”这一英文句子中，拿着望远镜的人是我，还是那个男人？在公园里的究竟是谁？人类之所以在大多数时候能够实现相互理解，是因为他们拥有着大量共同的知识和经验。但即便如此，人们之间的误解也依然时有发生。

为了解决上述问题，计算机科学家们专门设计了一系列能精确描述计算指令的符号系统，这些符号系统就是我们今天所知的*编程语言（Programming Languages）*。换而言之，编程语言就是一套计算机指令的编写规则，其中的每个组成单元都被定义了明确的含义（即语义）以及编写格式（即语法），正因为如此，我们所编写的程序通常被称为*计算机代码（Computer Code）*，而编写代码的过程则被称为*编码（Coding）*。举例来说，如果我们想让计算机将`1`和`2`这两个整数分别存储到`a`和`b`两个变量中，然后对它们执行加法运算，其操作指令在编程语言中的表述可能如下所示：

```assembly
section .data
a dd 1          ; 定义变量 a，并赋值为 1
b dd 2          ; 定义变量 b，并赋值为 2
c dd 0          ; 定义变量 c，并初始化为 0

section .text
global _start

_start:
    mov eax, [a]    ; 将变量 a 的值加载到寄存器 eax 中
    add eax, [b]    ; 将寄存器 eax 中的值与变量 b 的值相加，结果保存在 eax 中
    mov [c], eax    ; 将寄存器 eax 中的结果存储到变量 c 中

    ; 退出程序（在Linux环境下）
    mov eax, 1      ; 系统调用号 (sys_exit)
    xor ebx, ebx    ; 返回代码 0
    int 0x80        ; 调用内核
```

是不是觉得将两个整数相加的操作指令比想象的要复杂？很遗憾，由于编程语言的最终设计目标是方便人类的使用和理解，故而它们并不属于可被CPU直接执行的*机器语言（machine language）*，后者恐怕还得要用二进制的形式来表示。换而言之，上述指令在计算机中的真面目实际上是一个由`0`和`1`组成的数字序列，如果将两者对照起来看，可能会像下面这样：

```plaintext
MOV eax, [a]:   1011 00 000 0000 0000 0100 0000 0000 0000
ADD eax, [b]:   0000 00 000 0000 0000 0100 0000 0000 0100
MOV [c], eax:   1011 00 000 0000 0000 0100 0000 0000 1000
```

当然，我们在这里所展示的二进制代码只是一种示意性的表述，实际情况还得要取决于计算机具体采用的CPU架构。因此，尽管编程语言可以让我们的编程过程更容易一些，代码的可读性也更好一些，但这也意味着它需要先被“翻译”成机器语言，才能交由计算机硬件去执行。

### 语言分类

目前，尽管市面上现有的编程语言早已琳琅满目、语言的版本迭代也日新月异。但是，无论这些语言在各自实现上存在着多少不同之处，它们最终都需要被“翻译”成机器语言。根据翻译过程中所采用的具体方式，我们可以将编程语言大致分为以下三类：

- **汇编型语言（Assembly Languages）**：这是一种直接面向计算机硬件的编程语言，由于它将具体的CPU指令改编成了一系列更适合人类编写的助记符，所以在将基于汇编语言的程序交由计算机执行之前，通常需要先用一种被称作*汇编器（assembler）*的程序将其代码“翻译”回二进制形式的CPU指令。在这里，汇编语言的助记符与CPU指令之间是一一对应的关系，因而，不同的CPU架构使用的指令集通常是不同的，目前市面上较为常见的汇编型语言包括x86汇编、ARM汇编等。总而言之，汇编语言被认为是编程语言中最接近机器语言的一种，通常被称为*低级编程语言*。

- **编译型语言（Compiled Languages）**：这是一种经过抽象化定义的高级编程语言，目前市面上较为常见的编译型语言包括C、C++、Go、Rust等。这些语言被“翻译”的过程被称之为*编译（compiled）*。用于执行编译任务的*编译器（Compiler）*是一个由词法分析器、语法分析器、语义分析器、中间代码生成器、代码优化器以及目标代码生成器等组成的复杂程序，它的功能是分析并理解源代码中的指令，并将其翻译成与目标计算机硬件架构相匹配的机器语言。在其执行任务过程中，被编译的程序被称为*源代码（source code）*，而编译器所输出的就是可被计算机直接执行的*机器代码*。

- **解释型语言（Interpreted Languages）**：这也是一种抽象层次较高的高级编程语言，目前市面上较为常见的解释型语言包括JavaScript、Python、Ruby等。这些语言被“翻译”的过程被称之为*解释（interpreted）*。用于执行解释任务的*解释器（Interpreter）*本质上是一个虚拟程序，它的功能是虚拟一台能直接理解指定高级语言的计算机。换而言之，解释器不会将目标程序的源代码翻译成用机器语言表述的等效程序，它会在“运行程序”的过程中直接逐条分析并执行该源代码中的指令。

其中，编译型语言的翻译过程是一次性的，目标程序一旦完成了对源代码的编译，其结果就会以二进制可执行文件袋形式存储在计算机中，后续无论被运行多少次，都不再需要编译器或源代码的参与了。但是，如果目标程序采用的是解释型语言，那么它在计算机上的每次运行都需要有解释器和源代码的参与。也正因为如此，编译型语言通常能赋予程序更快的运行速度，因为它的翻译是一次完成的，而解释型语言则可以赋予人们更灵活的交互式编程体验，因为它的翻译是在程序每次运行过程中逐条进行的。

另外，我们从这里也可以看到高级编程语言相对于汇编语言的另一个优点：*可移植性（portability）*。一台计算机的机器语言通常是由其CPU的设计者创建的，因此每种类型的计算机都有属于的机器语言。这样一来，我们在笔记本中针对Intel i7处理器编写的程序，通常是无法直接运行在一台装有ARMv8处理器的智能手机上的。而在另一方面，只要拥有了合适的编译器或解释器（它们只不过是另一程序），使用高级语言编写的程序则是可以运行在各种不同类型的计算机上的。例如，我们完全可以在自己的笔记本和平板电脑上运行一模一样的Python程序，因为尽管这两台计算机中装载是不同的CPU，但他们都装配了可用于执行该程序的Python解释器。

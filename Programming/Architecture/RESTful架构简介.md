# RESTful 架构简介

想必使用过 PHP、JSP 这一类服务器动态页面技术的程序员应该都还记得，在使用这种传统的动态页面架构构建应用程序的时候，用于描述用户界面的 HTML 页面通常都是在服务器上完成渲染的。在这种情况下，应用程序的用户界面通常是无法针对用户所使用的软硬件环境做出具体的调整的，并且用户在绝大多数时候也只能通过 Web 浏览器来使用应用程序。这个问题在互联网用户只能使用 PC 的时代是可以忽略不计的，但在如今这个大量使用平板电脑、智能手机以及手表、手环等各种穿戴式智能设备的时代，用户所在的软硬件环境是千差万别的，再继续这种设计方法显然就有些难以为继了。为了解决这个问题，业界相继提出了 SOAP、XML-RPC 等设计现代化网络服务的解决方案，而 REST 正是其中被设计得较为简洁的一种方案。

REST 这套开发现代化互联网应用程序的解决方案最早是由罗伊·托马斯·菲尔丁（Roy Thomas Fielding）在 2000 年发表的博士论文中提出的[^1]，其设计目标是在应用程序的业务逻辑上实现前端与后端的分离，并在它们之间建立相互传递信息的行为规范，从而为应用程序的分布式部署创造基础。在编程方法论中，我们通常将遵守或兼容了这套软件设计规范的软件架构称为**RESTful 架构**。在接下来要构建的短书评应用程序中，我们就将基于这一架构来实现其后端部分的业务逻辑。当然了，在进行具体的项目实践之前，我们还是需要先对 RESTful 架构说规范的具体设计要求做一个基本的介绍。

## REST 设计规范

REST 这个词是 Representational State Transfer 的英文缩写，在中文中通常被翻译为**表现层状态转换**，在这个词中，*表现层*指的是互联网中各种资源实体的表现形式。例如，文本类型资源的表现形式既可以是 TXT 格式的文件，也可以是直接在网络中传递的字符串，图片类型资源的表现形式既可以是 PNG 格式的文件，也可以是存储在数据库中的一段二进制数据，简而言之，资源的表现层指的就是它在某个具体环境中的表现形式。具体到 HTTP 协议中，资源的表现层应该就是我们用来定位资源的统一资源标识符（以下简称 URI）了。但 HTTP 协议是一个无状态协议，这意味着，前端在使用 URI 请求相关资源的时候，它并不知道，也无需知道这些资源在后端服务中的具体表现形式，例如我们在向服务器请求某个图片资源的时候，事实上是无法，也不需要知道这个图片资源在后端服务中是一个存储在服务器磁盘上的 PNG 格式的文件，还是存储在数据库中的一个二进制数据。所有的这一切都需要应用程序的后端服务对 URI 这种表现形式执行*状态转换*，将其转换成指定的资源在服务器上的表现形式，然后才能执行一系列响应前端请求的操作。这里所描述的、后端服务针对资源表现形式的整个转换过程及其衍生出来的程序设计思路，就是 REST 提出的解决方案。

与 SOAP 本身是一个网络协议不同的是，REST 提出的解决方案本质上只是一套程序员们在编写软件时需要遵守的设计规范，它本身并没有定义任何新的网络协议和数据格式，相反，这套设计规范是建立在 HTTP、URI、XML 和 JSON 等一系列现有的网络协议和数据格式之上的。按照该设计规范的定义，一个基于 RESTful 架构的应用程序应该具备以下特征：

- 应用程序采用的是客户端-服务器（Client-Server）架构，其前后端在业务逻辑上是各自独立的，它们的具体分工如下：
  - 前端负责的是应用程序的用户界面，它的主要任务是根据用户的操作向后端请求指定的数据资源，并利用后端返回的数据为用户提供良好的使用体验。
  - 后端负责的则是应用程序的数据存储和业务运算，它的主要任务是监听并响应前端的请求，并利用服务器资源为用户提供海量数据存储与大规模运算的服务。

- 应用程序的前后端之间只能通过 HTTP 协议来进行数据交互，并且在交互数据时应该使用 XML 或 JSON 这一类通用数据格式。在具体交互过程中：
  - 前端在响应用户操作时应该始终以 URI 的形式向其后端所在的服务器请求服务，并在请求时使用只使用 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法来传递自己的请求信息。
  - 后端则只能根据其前端所使用的 HTTP 请求方法和 URI 来对存储在后端的数据执行增、删、改、查等操作，并将处理结果作为响应数据返回给前端。然后，由前端将响应数据以某种友好、可读的方式反馈给用户。

## 优势与劣势

正因为基于 RESTful 架构的应用程序所具备了上述特征，程序员们在开发和部署它们时才能获得一系列明显的优势，从而让 REST 这套设计规范成为了当前开发互联网应用程序的主要解决方案之一。在这里，我们可以简单地将这些优势归纳如下：

- **接口统一**：
  这是 RESTful 架构的设计初衷，它致力于让后端业务逻辑以统一接口的方式向前端提供服务，这样就简化了系统架构，降低了应用程序前后端之间的耦合性，以便于程序员们在开发整个应用程序可进行模块化分工。

- **分层系统**：
  RESTful 架构允许在后端构建基于多台服务器的分层系统服务。这意味着，应用程序的前端通常不需要知道自己连接的是最终的服务器，还是某台资源请求路径上的中间服务器。这更有助于我们在部署和维护应用程序时设置更为稳妥的服务器负载策略和其他安全性策略。

- **便于缓存**：
  正是因为 RESTful 架构构建的是一个分层系统，所以从前端到后端最后一台服务器上所有的节点都可以对一些特定的常用数据进行缓存，以前端界面与后端服务响应用户操作的速度。例如，我们可以在前端对不经常变化的 CSS 样式文件进行缓存，以减少向后端服务发送的请求数量，提升用户界面的加载速度。也可以在后端服务中对经常要执行的数据库查询建立缓存，以提升其响应请求的速度。
  
- **易于重构**：
  正是由于 RESTful 架构实现了应用程序的前后端在业务逻辑上的分离，降低它们之间的耦合度，这意味着我们对前端业务逻辑所进行的任何重构都基本上不会对后端的实现产生影响，反之亦然。例如我们既可以根据智能手机，PC 等不同客户端设备重构出不同的前端用户界面，也可以在用 JavaScript 基于 Node.js 运行环境编写的程序无法满足性能需求时，使用 Python、Go 等更适用于大规模科学运算的编程语言重构后端服务部分的业务逻辑。

当然了，RESTful 架构的相关特征在应用程序开发中是呈现出优势还是劣势，最终还得取决于程序员们的具体使用方法。例如，由于 RESTful 架构是基于 HTTP 这种无状态数据传输协议来进行通信的，这样做虽然有助于减低服务器的负担，并让后端服务的业务逻辑实现更为独立，但同时也意味着应用程序的后端服务无法记录前端的运行状态，前端必须自行利用相关机制（例如 Web 浏览器的会话机制）来记录应用程序的运行状态，以便在必要时将运行状态通报给后端，以减少一些不必要的响应数据，这算是在使用 RESTful 架构时需要会设法回避一个问题。

## 设计 RESTful API

通常情况下，我们会将基于 RESTful 架构所的后端服务形式称为 **RESTful API**。根据之前对 REST 设计规范的描述，基本上可以认为 RESTful API 应该具备以下特性：

- 应用程序的前端应使用 POST、GET、PUT 或 DELETE 等 HTTP 请求方法向后端服务发送请求。
- 应用程序的前端在发送请求时应统一使用直观简短的 URI 来表示自己要请求的资源。
- 应用程序的后端应对 URI 的表现形式进行状态转换，并根据前端使用的 HTTP 方法执行响应操作。
- 应用程序的前后端之间的数据传输应使用 XML、JSON 等通用的互联网媒体格式。

好了，想必读者已经对上面这些概念性的长篇大论感到有些不耐烦了，是时候通过示例来具体演示一下 RESTful API 的设计过程了。接下来，假设我们要创建一个功能简单的短书评应用，那么从资源角度来考虑，该应用程序后端服务器上的数据库中至少应该包含用户（`users`)、书籍（`books`）和书评帖子（`posts`）三张数据表，因此我们应该基于 RESTful 架构为前端提供以下 API：

![](../img/restful.png)

**表 7-1**：短书评应用程序的 RESTful API 设计

请注意，上述表格中列出的“请求路径”并非是一个完整的 URI。按照 REST 设计规范，完整的 URI 还应该包含调用 API 所使用的通信协议（通常是 HTTP 或 HTTPS），API 所在服务器的域名与端口号等相关信息。除此之外，如果我们还想兼顾 API 未来被重构之后可能引发的向后兼容问题，有时候也会选择在 URI 中加入版本信息[^2]。例如，如果我们将 API 部署在`localhost`这个域名下，服务端口为`3000`，那么前端想获取`<用户的ID>`值为`10`的个人信息，它使用 GET 方法发送 HTTP 请求的 URI 就应该是这样：

```bash
http://localhost:3000/v1/users/10
```

另外需要特别说明的是，人们在设计 RESTful API 时常常会下意识地犯一个设计理念上的错误，那就是将前端发送的 URI 设计成一个调用服务器函数的“动作”，例如在要获取指定用户发表的所有书评帖子时，我们极有可能将 URI 中的请求路径写成类似于`/posts/query?uid=10`这种形式，毕竟我们在 PHP、JSP 的时代一直是这么做的。但在 REST 设计规范中，表达调用的动作通常是由 HTTP 请求方法来传递的，URI 只用来指定前端需要后端服务提供的“资源”，所以它应该是一系列的名词，而非动词。

<!-- 以下为注释区 -->

[^1]: 罗伊·托马斯·菲尔丁（Roy Thomas Fielding）是HTTP协议（1.0版和1.1版）的主要设计者，同时也是Apache服务器软件的作者之一，并曾经担任Apache基金会的第一任主席。他于2000年发表了一篇题为*Architectural Styles and the Design of Network-based Software Architectures*的博士论文，一直以来都被称为是Web服务设计领域的”圣经”，并进而对当今互联网时代的软件设计产生了深远的影响。
[^2]: 当然，更为规范的做法是在 HTTP 请求头信息的`Accect`字段中指定版本信息。因为API的不同版本，也可以被理解成同一种资源的不同表现形式，所以理论上似乎应该采用同一个URI，但通常在实际生产环境中，这些规范未必能得到如此严格的遵守。
